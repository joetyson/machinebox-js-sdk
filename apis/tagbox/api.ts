// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * !!GENERATED FILE!!
 *
 * WARNING:  Do not edit this file, changes will be overwritten.
 *
 * Tagbox API
 * Tagbox API descriptors (unofficial)
 *
 * OpenAPI spec version: 1.0.1
 */

import * as url from 'url';
import { Configuration } from './configuration';
import axios, { AxiosPromise } from 'axios';

const BASE_PATH = 'http://localhost:8080'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration | undefined;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError' = 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface CheckApiResponse
 */
export interface CheckApiResponse {
  /**
   *
   * @type {boolean}
   * @memberof CheckApiResponse
   */
  success?: boolean;
  /**
   *
   * @type {Array<StandardTagScore>}
   * @memberof CheckApiResponse
   */
  tags?: Array<StandardTagScore>;
  /**
   *
   * @type {Array<CustomTagScore>}
   * @memberof CheckApiResponse
   */
  customTags?: Array<CustomTagScore>;
}

/**
 *
 * @export
 * @interface CheckImageRequest
 */
export interface CheckImageRequest {
  /**
   *
   * @type {string}
   * @memberof CheckImageRequest
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof CheckImageRequest
   */
  base64?: string;
}

/**
 *
 * @export
 * @interface CustomTagScore
 */
export interface CustomTagScore {
  /**
   * Tag within Tagbox
   * @type {string}
   * @memberof CustomTagScore
   */
  tag: string;
  /**
   *
   * @type {number}
   * @memberof CustomTagScore
   */
  confidence: number;
  /**
   * ID within Tagbox
   * @type {string}
   * @memberof CustomTagScore
   */
  id: string;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  build?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse200
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse200
   */
  version?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  plan?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  status?: string;
}

/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {boolean}
   * @memberof NotFoundError
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  error: string;
}

/**
 *
 * @export
 * @interface PatchTagRequest
 */
export interface PatchTagRequest {
  /**
   *
   * @type {string}
   * @memberof PatchTagRequest
   */
  tag: string;
}

/**
 *
 * @export
 * @interface RenameAllRequest
 */
export interface RenameAllRequest {
  /**
   *
   * @type {string}
   * @memberof RenameAllRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof RenameAllRequest
   */
  to?: string;
}

/**
 *
 * @export
 * @interface SimilarApiResponse
 */
export interface SimilarApiResponse {
  /**
   *
   * @type {boolean}
   * @memberof SimilarApiResponse
   */
  successs?: boolean;
  /**
   *
   * @type {number}
   * @memberof SimilarApiResponse
   */
  tagsCount?: number;
  /**
   *
   * @type {Array<CustomTagScore>}
   * @memberof SimilarApiResponse
   */
  similar?: Array<CustomTagScore>;
}

/**
 *
 * @export
 * @interface SimilarImageRequest
 */
export interface SimilarImageRequest {
  /**
   *
   * @type {string}
   * @memberof SimilarImageRequest
   */
  url?: string;
  /**
   *
   * @type {number}
   * @memberof SimilarImageRequest
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof SimilarImageRequest
   */
  base64?: string;
}

/**
 *
 * @export
 * @interface StandardTagScore
 */
export interface StandardTagScore {
  /**
   * Tag within Tagbox
   * @type {string}
   * @memberof StandardTagScore
   */
  tag: string;
  /**
   *
   * @type {number}
   * @memberof StandardTagScore
   */
  confidence: number;
}

/**
 *
 * @export
 * @interface SuccessfulAPIResponse
 */
export interface SuccessfulAPIResponse {
  /**
   *
   * @type {boolean}
   * @memberof SuccessfulAPIResponse
   */
  successs?: boolean;
}

/**
 *
 * @export
 * @interface TeachCustomTagRequest
 */
export interface TeachCustomTagRequest {
  /**
   * Tag within Tagbox
   * @type {string}
   * @memberof TeachCustomTagRequest
   */
  tag: string;
  /**
   * ID within Tagbox
   * @type {string}
   * @memberof TeachCustomTagRequest
   */
  id?: string;
  /**
   * URL to an image
   * @type {string}
   * @memberof TeachCustomTagRequest
   */
  url?: string;
  /**
   * Base64 encoded image
   * @type {string}
   * @memberof TeachCustomTagRequest
   */
  base64?: string;
}

/**
 *
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   *
   * @type {boolean}
   * @memberof UnauthorizedError
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  error: string;
}

/**
 *
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
  /**
   *
   * @type {boolean}
   * @memberof UnexpectedError
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  error: string;
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Returns some basic details about the box.
     * @summary GetBoxInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoxInfo(options: any = {}): RequestArgs {
      const localVarPath = `/info`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Returns some basic details about the box.
     * @summary GetBoxInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoxInfo(
      options?: any
    ): (basePath?: string) => AxiosPromise<InlineResponse200> {
      const localVarAxiosArgs = MetadataApiAxiosParamCreator(
        configuration
      ).getBoxInfo(options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function(
  configuration?: Configuration,
  basePath?: string
) {
  return {
    /**
     * Returns some basic details about the box.
     * @summary GetBoxInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoxInfo(options?: any) {
      return MetadataApiFp(configuration).getBoxInfo(options)(basePath);
    },
  };
};

/**
 * MetadataApi - interface
 * @export
 * @interface MetadataApi
 */
export interface MetadataApiInterface {
  /**
   * Returns some basic details about the box.
   * @summary GetBoxInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApiInterface
   */
  getBoxInfo(options?: any): AxiosPromise<InlineResponse200>;
}

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI implements MetadataApiInterface {
  /**
   * Returns some basic details about the box.
   * @summary GetBoxInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApi
   */
  public getBoxInfo(options?: any) {
    return MetadataApiFp(this.configuration).getBoxInfo(options)(this.basePath);
  }
}

/**
 * TagboxApi - axios parameter creator
 * @export
 */
export const TagboxApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Get tags for a specified image
     * @summary CheckImage
     * @param {CheckImageRequest} [checkImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkImage(
      checkImageRequest?: CheckImageRequest,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/tagbox/check`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'CheckImageRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(checkImageRequest || {})
        : checkImageRequest || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a tag that has been previously taught
     * @summary Remove
     * @param {string} id The unique identifier of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling remove.'
        );
      }
      const localVarPath = `/tagbox/teach/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get tags for a specified image
     * @summary RenameAll
     * @param {string} id The unique identifier of the item to patch
     * @param {RenameAllRequest} [renameAllRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renameAll(
      id: string,
      renameAllRequest?: RenameAllRequest,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling renameAll.'
        );
      }
      const localVarPath = `/tagbox/rename/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'RenameAllRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(renameAllRequest || {})
        : renameAllRequest || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get tags for a specified image
     * @summary RenameTagByID
     * @param {string} id The unique identifier of the item to patch
     * @param {PatchTagRequest} [patchTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renameTagByID(
      id: string,
      patchTagRequest?: PatchTagRequest,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling renameTagByID.'
        );
      }
      const localVarPath = `/tagbox/rename/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'PatchTagRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(patchTagRequest || {})
        : patchTagRequest || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns similar images based on the ID provided
     * @summary SimilarID
     * @param {string} id
     * @param {number} [limit] Format - double.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    similarID(id: string, limit?: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling similarID.'
        );
      }
      const localVarPath = `/tagbox/similar`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Checks the image at the specified source for similar images based on tags previously taught.
     * @summary SimilarImage
     * @param {SimilarImageRequest} [similarImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    similarImage(
      similarImageRequest?: SimilarImageRequest,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/tagbox/similar`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'SimilarImageRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(similarImageRequest || {})
        : similarImageRequest || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use the /tagbox/teach endpoint to teach Tagbox a tag
     * @summary TeachCustomTag
     * @param {TeachCustomTagRequest} [teachCustomTagRequest] Teach TagBot about a tag in a specified image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teachCustomTag(
      teachCustomTagRequest?: TeachCustomTagRequest,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/tagbox/teach`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      if (configuration && configuration.userAgent) {
        localVarHeaderParameter['User-Agent'] = configuration.userAgent;
      } else {
        localVarHeaderParameter['User-Agent'] =
          'Machinebox-SDK/1.0.1/javascript';
      }
      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'TeachCustomTagRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(teachCustomTagRequest || {})
        : teachCustomTagRequest || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TagboxApi - functional programming interface
 * @export
 */
export const TagboxApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get tags for a specified image
     * @summary CheckImage
     * @param {CheckImageRequest} [checkImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkImage(
      checkImageRequest?: CheckImageRequest,
      options?: any
    ): (basePath?: string) => AxiosPromise<CheckApiResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).checkImage(checkImageRequest, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Remove a tag that has been previously taught
     * @summary Remove
     * @param {string} id The unique identifier of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(
      id: string,
      options?: any
    ): (basePath?: string) => AxiosPromise<SuccessfulAPIResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).remove(id, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get tags for a specified image
     * @summary RenameAll
     * @param {string} id The unique identifier of the item to patch
     * @param {RenameAllRequest} [renameAllRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renameAll(
      id: string,
      renameAllRequest?: RenameAllRequest,
      options?: any
    ): (basePath?: string) => AxiosPromise<SuccessfulAPIResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).renameAll(id, renameAllRequest, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get tags for a specified image
     * @summary RenameTagByID
     * @param {string} id The unique identifier of the item to patch
     * @param {PatchTagRequest} [patchTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renameTagByID(
      id: string,
      patchTagRequest?: PatchTagRequest,
      options?: any
    ): (basePath?: string) => AxiosPromise<SuccessfulAPIResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).renameTagByID(id, patchTagRequest, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns similar images based on the ID provided
     * @summary SimilarID
     * @param {string} id
     * @param {number} [limit] Format - double.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    similarID(
      id: string,
      limit?: number,
      options?: any
    ): (basePath?: string) => AxiosPromise<SimilarApiResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).similarID(id, limit, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Checks the image at the specified source for similar images based on tags previously taught.
     * @summary SimilarImage
     * @param {SimilarImageRequest} [similarImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    similarImage(
      similarImageRequest?: SimilarImageRequest,
      options?: any
    ): (basePath?: string) => AxiosPromise<SimilarApiResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).similarImage(similarImageRequest, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Use the /tagbox/teach endpoint to teach Tagbox a tag
     * @summary TeachCustomTag
     * @param {TeachCustomTagRequest} [teachCustomTagRequest] Teach TagBot about a tag in a specified image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teachCustomTag(
      teachCustomTagRequest?: TeachCustomTagRequest,
      options?: any
    ): (basePath?: string) => AxiosPromise<SuccessfulAPIResponse> {
      const localVarAxiosArgs = TagboxApiAxiosParamCreator(
        configuration
      ).teachCustomTag(teachCustomTagRequest, options);
      return (basePath: string = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {
          url: basePath + localVarAxiosArgs.url,
        });
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TagboxApi - factory interface
 * @export
 */
export const TagboxApiFactory = function(
  configuration?: Configuration,
  basePath?: string
) {
  return {
    /**
     * Get tags for a specified image
     * @summary CheckImage
     * @param {CheckImageRequest} [checkImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkImage(checkImageRequest?: CheckImageRequest, options?: any) {
      return TagboxApiFp(configuration).checkImage(checkImageRequest, options)(
        basePath
      );
    },
    /**
     * Remove a tag that has been previously taught
     * @summary Remove
     * @param {string} id The unique identifier of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(id: string, options?: any) {
      return TagboxApiFp(configuration).remove(id, options)(basePath);
    },
    /**
     * Get tags for a specified image
     * @summary RenameAll
     * @param {string} id The unique identifier of the item to patch
     * @param {RenameAllRequest} [renameAllRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renameAll(id: string, renameAllRequest?: RenameAllRequest, options?: any) {
      return TagboxApiFp(configuration).renameAll(
        id,
        renameAllRequest,
        options
      )(basePath);
    },
    /**
     * Get tags for a specified image
     * @summary RenameTagByID
     * @param {string} id The unique identifier of the item to patch
     * @param {PatchTagRequest} [patchTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renameTagByID(
      id: string,
      patchTagRequest?: PatchTagRequest,
      options?: any
    ) {
      return TagboxApiFp(configuration).renameTagByID(
        id,
        patchTagRequest,
        options
      )(basePath);
    },
    /**
     * Returns similar images based on the ID provided
     * @summary SimilarID
     * @param {string} id
     * @param {number} [limit] Format - double.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    similarID(id: string, limit?: number, options?: any) {
      return TagboxApiFp(configuration).similarID(id, limit, options)(basePath);
    },
    /**
     * Checks the image at the specified source for similar images based on tags previously taught.
     * @summary SimilarImage
     * @param {SimilarImageRequest} [similarImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    similarImage(similarImageRequest?: SimilarImageRequest, options?: any) {
      return TagboxApiFp(configuration).similarImage(
        similarImageRequest,
        options
      )(basePath);
    },
    /**
     * Use the /tagbox/teach endpoint to teach Tagbox a tag
     * @summary TeachCustomTag
     * @param {TeachCustomTagRequest} [teachCustomTagRequest] Teach TagBot about a tag in a specified image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teachCustomTag(
      teachCustomTagRequest?: TeachCustomTagRequest,
      options?: any
    ) {
      return TagboxApiFp(configuration).teachCustomTag(
        teachCustomTagRequest,
        options
      )(basePath);
    },
  };
};

/**
 * TagboxApi - interface
 * @export
 * @interface TagboxApi
 */
export interface TagboxApiInterface {
  /**
   * Get tags for a specified image
   * @summary CheckImage
   * @param {CheckImageRequest} [checkImageRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  checkImage(
    checkImageRequest?: CheckImageRequest,
    options?: any
  ): AxiosPromise<CheckApiResponse>;

  /**
   * Remove a tag that has been previously taught
   * @summary Remove
   * @param {string} id The unique identifier of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  remove(id: string, options?: any): AxiosPromise<SuccessfulAPIResponse>;

  /**
   * Get tags for a specified image
   * @summary RenameAll
   * @param {string} id The unique identifier of the item to patch
   * @param {RenameAllRequest} [renameAllRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  renameAll(
    id: string,
    renameAllRequest?: RenameAllRequest,
    options?: any
  ): AxiosPromise<SuccessfulAPIResponse>;

  /**
   * Get tags for a specified image
   * @summary RenameTagByID
   * @param {string} id The unique identifier of the item to patch
   * @param {PatchTagRequest} [patchTagRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  renameTagByID(
    id: string,
    patchTagRequest?: PatchTagRequest,
    options?: any
  ): AxiosPromise<SuccessfulAPIResponse>;

  /**
   * Returns similar images based on the ID provided
   * @summary SimilarID
   * @param {string} id
   * @param {number} [limit] Format - double.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  similarID(
    id: string,
    limit?: number,
    options?: any
  ): AxiosPromise<SimilarApiResponse>;

  /**
   * Checks the image at the specified source for similar images based on tags previously taught.
   * @summary SimilarImage
   * @param {SimilarImageRequest} [similarImageRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  similarImage(
    similarImageRequest?: SimilarImageRequest,
    options?: any
  ): AxiosPromise<SimilarApiResponse>;

  /**
   * Use the /tagbox/teach endpoint to teach Tagbox a tag
   * @summary TeachCustomTag
   * @param {TeachCustomTagRequest} [teachCustomTagRequest] Teach TagBot about a tag in a specified image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApiInterface
   */
  teachCustomTag(
    teachCustomTagRequest?: TeachCustomTagRequest,
    options?: any
  ): AxiosPromise<SuccessfulAPIResponse>;
}

/**
 * TagboxApi - object-oriented interface
 * @export
 * @class TagboxApi
 * @extends {BaseAPI}
 */
export class TagboxApi extends BaseAPI implements TagboxApiInterface {
  /**
   * Get tags for a specified image
   * @summary CheckImage
   * @param {CheckImageRequest} [checkImageRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public checkImage(checkImageRequest?: CheckImageRequest, options?: any) {
    return TagboxApiFp(this.configuration).checkImage(
      checkImageRequest,
      options
    )(this.basePath);
  }

  /**
   * Remove a tag that has been previously taught
   * @summary Remove
   * @param {string} id The unique identifier of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public remove(id: string, options?: any) {
    return TagboxApiFp(this.configuration).remove(id, options)(this.basePath);
  }

  /**
   * Get tags for a specified image
   * @summary RenameAll
   * @param {string} id The unique identifier of the item to patch
   * @param {RenameAllRequest} [renameAllRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public renameAll(
    id: string,
    renameAllRequest?: RenameAllRequest,
    options?: any
  ) {
    return TagboxApiFp(this.configuration).renameAll(
      id,
      renameAllRequest,
      options
    )(this.basePath);
  }

  /**
   * Get tags for a specified image
   * @summary RenameTagByID
   * @param {string} id The unique identifier of the item to patch
   * @param {PatchTagRequest} [patchTagRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public renameTagByID(
    id: string,
    patchTagRequest?: PatchTagRequest,
    options?: any
  ) {
    return TagboxApiFp(this.configuration).renameTagByID(
      id,
      patchTagRequest,
      options
    )(this.basePath);
  }

  /**
   * Returns similar images based on the ID provided
   * @summary SimilarID
   * @param {string} id
   * @param {number} [limit] Format - double.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public similarID(id: string, limit?: number, options?: any) {
    return TagboxApiFp(this.configuration).similarID(id, limit, options)(
      this.basePath
    );
  }

  /**
   * Checks the image at the specified source for similar images based on tags previously taught.
   * @summary SimilarImage
   * @param {SimilarImageRequest} [similarImageRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public similarImage(
    similarImageRequest?: SimilarImageRequest,
    options?: any
  ) {
    return TagboxApiFp(this.configuration).similarImage(
      similarImageRequest,
      options
    )(this.basePath);
  }

  /**
   * Use the /tagbox/teach endpoint to teach Tagbox a tag
   * @summary TeachCustomTag
   * @param {TeachCustomTagRequest} [teachCustomTagRequest] Teach TagBot about a tag in a specified image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagboxApi
   */
  public teachCustomTag(
    teachCustomTagRequest?: TeachCustomTagRequest,
    options?: any
  ) {
    return TagboxApiFp(this.configuration).teachCustomTag(
      teachCustomTagRequest,
      options
    )(this.basePath);
  }
}
